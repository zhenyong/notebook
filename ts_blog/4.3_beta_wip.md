## Separate Write Types on Properties

```
class Thing {
    #size = 0;

    get size(): number {
        return this.#size;
    }

    set size(value: string | number | boolean) {
        let num = Number(value);

        // Don't allow NaN and stuff.
        if (!Number.isFinite(num)) {
            this.#size = 0;
            return;
        }

        this.#size = num;
    }
}
```

before:

![image](https://user-images.githubusercontent.com/4012276/117753485-1fc18680-b24b-11eb-8162-52a32b315bf5.png)

after:

- 读写类型分开
- setter 类型 包含 getter 类型

## override and the --noImplicitOverride Flag

>https://github.com/microsoft/TypeScript/pull/39669

效果：
1. 启用 noImplicitOverride 才会生效
2. 重写的成员需要加 override

## template string types

新的类型：模板字符串

```
function bar(s: string): `hello ${string}` {
    return `hello ${s}`;
}
```

before: 报错，认为 return 后面是个 string 导致报错

after: 探测到返回是模板字符串，就认为是个模板字符串类型

## ECMAScript #private Class Elements

真正的私有属性，实例访问不了带 # 的成员

## Always-Truthy Promise Checks

Promise 值不能用于条件判断，永远为布尔真

```
async function foo(): Promise<boolean> {
    return false;
}
if(foo()) // 报错
```

## static Index Signatures

对索引变量属性，支持 static
```
Class Foo {
    static prop = true; // 报错，必须属于下面的 string | number 类型之一
    static [props: string]: string | number
}
```





